#!/bin/bash

# This script is like to egrep, but can search in any type of files.
# First, it converts the file to plain text, then run grep on this plain text output.
# You can use the same options as for grep, with some exception.
# File matching and recursion options will be handled by the script itself.
# By default, extended regular expressions will be used.
# There are additional options too, e. g. `-t`/`--type`.

GREP_OPTS_WITH_PARAM='-e --regexp -f --file -m --max-count --label -A --after-context -B -before-context -C --context --group-separator --binary-files -D --devices -d --directories --exclude --exclude-from --exclude-dir --include'

function write() {
    printf '%s\n' "$1"
}

function escape_argument() {
    echo "'$( write "$1" | sed -E 's/'"'"'/'"'"'"'"'"'"'"'"'/g' )'"
}

function glob_match() {
    glob="$1"
    path="$2"
    
    # TODO: glob match
    
    return 0
}

function rule_match() {
    path="$1"
    includes="$2"
    excludes="$3"
    
    if ! [ -f "$path" ]; then
        exit 1
    fi

    realPath="$( realpath "$path" )"
    
    IFS=$'\n'
    for exclude in $excludes; do
        if glob_match "$exclude" "$realPath"; then
            return 1
        fi
    done
    
    hasIncludes=''
    IFS=$'\n'
    for include in $includes; do
        hasIncludes='1'
        if glob_match "$include" "$realPath"; then
            return 0
        fi
    done
    
    if [ "$hasIncludes" == '' ]; then
        return 0
    else
        return 1
    fi
}

function detect_type() {
    path="$1"
    
    filename="$( basename -- "$path" )"
    extension="${filename##*.}"
    if [ "$extension" != "$filename" ]; then
        write "$extension"
    fi
}

function calculate_type() {
    explicitType="$1"
    path="$2"
    
    if [ -n "$explicitType" ]; then
        write "$explicitType"
    else
        detect_type "$path"
    fi
}

function search_in_file() {
    grepCommand="$1"
    path="$2"
    type="$3"
    includes="$4"
    excludes="$5"
    
    if ! rule_match "$path" "$includes" "$excludes"; then
        return 1
    fi
    
    calculatedType="$( calculate_type "$type" "$path" )"
    if [ "$calculatedType" == 'pdf' ]; then
        command="pdftotext $( escape_argument "$path" ) - 2>/dev/null | ${grepCommand}"
    else
        additionalPandocParameters=""
        if [ -n "$type" ]; then
            additionalPandocParameters=" $( escape_argument "--from=${type}" )"
        fi
        command="pandoc $( escape_argument "$path" ) --to 'txt' additionalPandocParameters | ${grepCommand}"
    fi
    
    output="$( sh -c "$command" )"
    if [ -n "$output" ]; then
        write "--------- ${path}:"
        echo ""
        write "$output"
        echo ""
    fi
}

function search_in_directory() {
    grepCommand="$1"
    path="$2"
    type="$3"
    includes="$4"
    excludes="$5"
    
    # TODO: recursive search in directory
    
    echo "DIR: $path / $exclusions / $grepCommand"
}

type=''
escapedIncludeOptions=''
includes=''
escapedExcludeOptions=''
excludes=''
escapedOptions=''
searchString=''
searchStringFound=''
paths=''
isRecursive=''
isDereferenceRecursive=''
nextIsInclude=''
nextIsExclude=''
nextIsGrepParam=''
for arg in "$@"; do
    if [ "$nextIsInclude" == '1' ]; then
        escapedIncludeOptions="${escapedIncludeOptions} $( escape_argument "--include=$arg" )"
        includes="${includes}${arg}"$'\n'
        nextIsInclude='0'
    elif [ "$nextIsExclude" == '1' ]; then
        escapedExcludeOptions="${escapedExcludeOptions} $( escape_argument "--exclude=$arg" )"
        excludes="${excludes}${arg}"$'\n'
        nextIsExclude='0'
    elif [ "$nextIsGrepParam" == '1' ]; then
        escapedOptions="${escapedOptions} $( escape_argument "$arg" )"
        nextIsGrepParam='0'
    elif [ "$nextIsType" == '1' ]; then
        type="$arg"
        nextIsType='0'
    elif [ "$arg" == '-r' ] || [ "$arg" == '--recursive' ]; then
        isRecursive='1'
    elif [ "$arg" == '-R' ] || [ "$arg" == '--dereference-recursive' ]; then
        isDereferenceRecursive='1'
    elif [ "$arg" == '--include' ]; then
        nextIsInclude='1'
    elif [[ "$arg" =~ --include=(.*) ]]; then
        escapedIncludeOptions="${escapedIncludeOptions} $( escape_argument "$arg" )"
        includes="${includes}${BASH_REMATCH[1]}"$'\n'
    elif [ "$arg" == '--exclude' ]; then
        nextIsExclude='1'
    elif [[ "$arg" =~ --exclude=(.*) ]]; then
        escapedExcludeOptions="${escapedExcludeOptions} $( escape_argument "$arg" )"
        excludes="${excludes}${BASH_REMATCH[1]}"$'\n'
    elif [ "$arg" == '--color' ]; then
        escapedOptions="${escapedOptions} $( escape_argument '--color=always' )"
    elif [ "$arg" == '--type' ]; then
        nextIsType='1'
    elif [[ "$arg" == -* ]]; then
        escapedOptions="${escapedOptions} $( escape_argument "$arg" )"
        if [[ " ${GREP_OPTS_WITH_PARAM} " =~ [[:space:]]$arg[[:space:]] ]]; then
            nextIsGrepParam='1'
        fi
    elif [ -z "$searchStringFound" ]; then
        searchString="$arg"
        searchStringFound='1'
    else
        paths="${paths}${arg}"$'\n'
    fi
done

# TODO: handle regex flavour options -E, -F, -G, -P

grepCommand="grep $( escape_argument "$searchString" ) ${escapedOptions}"

IFS=$'\n'
for path in $paths; do
    if [ -f ]; then
        search_in_file "$grepCommand" "$path" "$type" "$includes" "$excludes"
    fi
    
    # TODO: recursion
    
done
